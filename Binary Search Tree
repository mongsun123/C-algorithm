#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <chrono>
using namespace std;

struct Property {
    int ads_id;
    string prop_name;
    string completion_year;
    string monthly_rent;
    string location;
    string property_type;
    string rooms;
    string parking;
    string bathroom;
    string size;
    string furnished;
    vector<string> facilities;
    vector<string> additional_facilities;
    string region;
    Property* prev, * next; // add prev and next pointers

    Property* left;   // left child for BST
    Property* right;  // right child for BST

    Property() : left(nullptr), right(nullptr), prev(nullptr), next(nullptr) {} //This list initializes the pointers to nullptr whenever a new instance of Property is created.
};

Property* bstInsert(Property* root, Property prop) {
    if (root == nullptr) {
        root = new Property();
        *root = prop;  // copy the data
    }
    else if (prop.ads_id < root->ads_id) {
        root->left = bstInsert(root->left, prop);
    }
    else {
        root->right = bstInsert(root->right, prop);
    }

    return root;
}

vector<string> split(const string& s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

Property* read_csv(string filename) {
    ifstream file(filename);
    string line, word;
    getline(file, line); // Skip the header line

    Property* root = nullptr;

    while (getline(file, line)) {
        stringstream s(line);
        int ads_id;
        string prop_name, completion_year, monthly_rent, location, property_type, rooms, parking, bathroom, size, furnished, region;
        vector<string> facilities, additional_facilities;
        int column_index = 0;

        // ... [Your CSV parsing code here] ...
        while (getline(s, word, ',')) {
            if (word[0] == '"') {
                while (word.back() != '"' || word.size() < 2) {
                    string extra_word;
                    getline(s, extra_word, ',');
                    word += "," + extra_word;
                }
                word = word.substr(1, word.size() - 2);
            }

            switch (column_index) {
            case 0:
                ads_id = stoi(word);
                break;
            case 1:
                prop_name = word;
                break;
            case 2:
                completion_year = word;
                break;
            case 3:
                monthly_rent = word;
                break;
            case 4:
                location = word;
                break;
            case 5:
                property_type = word;
                break;
            case 6:
                rooms = word;
                break;
            case 7:
                parking = word;
                break;
            case 8:
                bathroom = word;
                break;
            case 9:
                size = word;
                break;
            case 10:
                furnished = word;
                break;
            case 11:
                facilities = split(word, ',');
                break;
            case 12:
                additional_facilities = split(word, ',');
                break;
            case 13:
                region = word;
                break;
            }
            column_index++;
        }
        // Create a new property struct
        Property newProperty;
        newProperty.ads_id = ads_id;
        newProperty.prop_name = prop_name;
        newProperty.completion_year = completion_year;
        newProperty.monthly_rent = monthly_rent;
        newProperty.location = location;
        newProperty.property_type = property_type;
        newProperty.rooms = rooms;
        newProperty.parking = parking;
        newProperty.bathroom = bathroom;
        newProperty.size = size;
        newProperty.furnished = furnished;
        newProperty.facilities = facilities;
        newProperty.additional_facilities = additional_facilities;
        newProperty.region = region;

        // Insert the property into the BST
        root = bstInsert(root, newProperty);
    }

    return root; // This now returns the root of the BST instead of the head of the linked list
}

Property* bstSearch(Property* root, int ads_id) {
    if (root == nullptr || root->ads_id == ads_id) {
        return root;
    }

    if (root->ads_id < ads_id) {
        return bstSearch(root->right, ads_id);
    }

    return bstSearch(root->left, ads_id);
}

// Helper function to find the minimum value node in a subtree
Property* findMinValueNode(Property* root) {
    Property* current = root;

    while (current && current->left != nullptr) {
        current = current->left;
    }

    return current;
}


Property* bstDelete(Property* root, int ads_id) {
    if (root == nullptr) return root;

    if (ads_id < root->ads_id) {
        root->left = bstDelete(root->left, ads_id);
    }
    else if (ads_id > root->ads_id) {
        root->right = bstDelete(root->right, ads_id);
    }
    else {
        if (root->left == nullptr) {
            Property* temp = root->right;
            delete root;
            return temp;
        }
        else if (root->right == nullptr) {
            Property* temp = root->left;
            delete root;
            return temp;
        }

        Property* temp = findMinValueNode(root->right);
        root = temp;
        root->right = bstDelete(root->right, temp->ads_id);
    }

    return root;
}

// Function to print a property (for demonstration purposes)
void printProperty(Property* prop) {
    if (prop == nullptr) {
        cout << "Property not found." << endl;
        return;
    }

    cout << "Property ID: " << prop->ads_id << endl;
    cout << "Property Name: " << prop->prop_name << endl;
    cout << "Location: " << prop->location << endl;
    cout << "Monthly Rent: " << prop->monthly_rent << endl;
    // ... [You can add more fields to display if you want] ...
    cout << endl;
}

// Recursive function to print BST pre-order (for demonstration purposes)
void preOrder(Property* root) {
    if (root == nullptr) return;

    //printProperty(root);
    inOrder(root->left);
    inOrder(root->right);
}

// Recursive function to print BST in-order (for demonstration purposes)
void inOrder(Property* root) {
    if (root == nullptr) return;

    inOrder(root->left);
    //printProperty(root);
    inOrder(root->right);
}

// Recursive function to print BST post-order (for demonstration purposes)
void postOrder(Property* root) {
    if (root == nullptr) return;

    inOrder(root->left);
    inOrder(root->right);
    //printProperty(root);
}

int main() {
    string filename = "C:/Users/Sniper Ulti/Downloads/mudah-apartment-kl-selangor.csv";  // Replace with the path to your CSV file
    
    // Start measuring time
    auto start = chrono::high_resolution_clock::now();
    Property* root = read_csv(filename);

    // Stop measuring time and calculate the elapsed time
    auto stop = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::seconds>(stop - start);

    cout << "Time taken by read_csv function: " << duration.count() << " seconds" << endl;


    // Start measuring time
    auto start1 = chrono::high_resolution_clock::now();

    cout << "Properties in BST (in-order):" << endl;
    inOrder(root);
    cout << "--------------------------------" << endl;

    // Stop measuring time and calculate the elapsed time
    auto stop1 = chrono::high_resolution_clock::now();
    auto duration1 = chrono::duration_cast<chrono::seconds>(stop - start);

    cout << "Time taken by read_csv function: " << duration.count() << " seconds" << endl;


    // Start measuring time
    auto start2 = chrono::high_resolution_clock::now();

    int searchId = 100310024;  // Replace with an ads_id you want to search for
    Property* searchResult = bstSearch(root, searchId);
    cout << "Searching for property with ads_id " << searchId << ":" << endl;
    printProperty(searchResult);
    cout << "--------------------------------" << endl;

    // Stop measuring time and calculate the elapsed time
    auto stop2 = chrono::high_resolution_clock::now();
    auto duration2 = chrono::duration_cast<chrono::seconds>(stop - start);

    cout << "Time taken by read_csv function: " << duration.count() << " seconds" << endl;



    int deleteId = 17;  // Replace with an ads_id you want to delete
    cout << "Deleting property with ads_id " << deleteId << ":" << endl;
    root = bstDelete(root, deleteId);
    cout << "Properties in BST after deletion (in-order):" << endl;
    inOrder(root);
    cout << "--------------------------------" << endl;

    // Cleanup: Ideally, you'd want to delete all nodes from the BST to prevent memory leaks.
    // This would require a function to recursively delete all nodes.

    return 0;
}
